#pragma config(Sensor, in5,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl2,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LED1,           sensorNone)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armLeft,       tmotorVex269, openLoop)
#pragma config(Motor,  port8,           armRight,      tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port9,           eleBotLeft,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          eleBotRight,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"


void motors(int speed)
{
	motor[backRight] = speed;
	motor[backLeft] = speed;
	motor[frontRight] = speed;
	motor[frontLeft] = speed;
}


void drive(int rot)
{
	if(rot > 0)
	{
		while(SensorValue(encoderRight) > rot)
		{
				motor[frontRight] = 63;
				motor[backRight] = 63;
				motor[frontLeft] = 63;
				motor[backLeft] = 63;
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
	else
	{
		while(SensorValue(encoderRight) < rot)
			{
					motor[frontRight] = -63;
					motor[backRight] = -63;
					motor[frontLeft] = -63;
					motor[backLeft] = -63;
			}
			motor[frontRight] = 0;
			motor[backRight] = 0;
			motor[frontLeft] = 0;
			motor[backLeft] = 0;
	}
}

void turn90(int d)
{
	if(d == 1)
	{
		while(SensorValue(encoderLeft) > 720)
		{
			motor[frontLeft] = 63;
			motor[backLeft] = 63;
		}
	}
	if(d == -1)
	{
		while(SensorValue(encoderRight) > 720)
		{
			motor[frontRight] = 63;
			motor[backRight] = 63;
		}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}




//void forward(int distance)
//{
//	 if (SensorValue(encoderRight) > distance)
// 	  {
//		 motor[frontRight] = -30;
//		 motor[backRight] = -30;
//	  }

//   if (SensorValue(encoderLeft) > distance)
//     {
//       motor[frontLeft] = -30;
//       motor[backLeft] = -30;
//     }

//	 if (SensorValue(encoderRight) == distance && SensorValue(encoder2) == distance)
//		{
//			motor[backRight] = 0;
//			motor[backLeft] = 0;
//			motor[frontLeft] = 0;
//			motor[frontRight] = 0;
//		}

//		else
//		{
//			forward(distance);
//	  }

//}


void pre_auton()
{
}


task autonomous()
{
		motor[backLeft] = -63;
	motor[frontLeft] = -63;
	motor[backRight] = -63;
	motor[frontRight] = -63;
	wait1Msec(3300);
	motors(0);
	motor[eleBotLeft] = 127;
	motor[eleBotRight] = 127;
	wait1Msec(1800);
	motor[eleBotLeft] = -63;
	motor[eleBotRight] = -63;
	wait1Msec(2000);
	motor[eleBotLeft] = 0;
	motor[eleBotRight] = 0;

}

task usercontrol()
{

	while (true)
	{
	  	//  Arcade Drive
		motor[frontRight] = vexRT[Ch3] - vexRT[Ch4];
		motor[backRight] = vexRT[Ch3] - vexRT[Ch4];
		motor[frontLeft] = vexRT[Ch3] + vexRT[Ch4];
		motor[backLeft] = vexRT[Ch3] + vexRT[Ch4];

		//Elevator Code
		if (vexRT[Btn5U] == true)
		{
			motor[eleBotRight] = 127;
			motor[eleBotLeft] = 127;
		}
		else
		{
			if (vexRT[Btn5D] == true)
			{
				motor[eleBotRight] = -127;
				motor[eleBotLeft] = -127;
			}
			else
			{
				motor[eleBotLeft] = 0;
				motor[eleBotRight] = 0;
			}




		}
		// Arm Code.
		if (SensorValue[armPot] < 3555)
		{
      motor[armLeft] = vexRT[Ch2];
			motor[armRight] = vexRT[Ch2];
 		}
 		else
		{
			motor[armLeft] = -35;
			motor[armRight] = -35;
		}


		// "Bottons to move a little bit." Said Alex
		if (vexRT[Btn7U] == true)
		{
			motor[frontRight] = 35;
	   	motor[backRight] = 35;
		  motor[frontLeft] = 35;
		  motor[backLeft] = 35;
		}
		if (vexRT[Btn7R] == true)
		{
			motor[frontRight] = -35;
	   	motor[backRight] = -35;
		  motor[frontLeft] = 35;
		  motor[backLeft] = 35;
		}
		if (vexRT[Btn7D] == true)
		{
		  motor[frontRight] = -35;
	   	motor[backRight] = -35;
		  motor[frontLeft] = -35;
		  motor[backLeft] = -35;
		}
		if (vexRT[Btn7L] == true)

		{
		  motor[frontRight] = 35;
	   	motor[backRight] = 35;
		  motor[frontLeft] = -35;
		  motor[backLeft] = -35;
		}
		if (vexRT[Btn6U] == true)
			{
				while( SensorValue[encoderRight] < 360)
					{
						motor[frontRight] = 63;
						motor[backRight] = 63;
					}
		  }
	}
}
