#pragma config(Sensor, in5,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encoder1,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  LED1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, sonar1,         sensorSONAR_mm)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armLeft,       tmotorVex269, openLoop)
#pragma config(Motor,  port8,           armRight,      tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port9,           eleBotLeft,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          eleBotRight,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
bool close = false;
//bool done = false;
void getCloser()
{
	if(SensorValue[sonar1] > 99 || SensorValue[sonar1] == -1)
	{
		motor[backLeft] = -45;
		motor[frontLeft] = -45;
		motor[backRight] = -45;
		motor[frontRight] = -45;
		close = false;
	}
	if(SensorValue[sonar1] < 99)
	{
		motor[backLeft] = 0;
		motor[frontLeft] = 0;
		motor[backRight] = 0;
		motor[frontRight] = 0;
		close = true;
	}
}

void turn90(int positive)  //1 = right, -1 = left
{
	motor[frontLeft] = 127 * positive;
	motor[frontRight] = -127 * positive;
	motor[backLeft] = 127 * positive;
	motor[backRight] = -127 * positive;
	wait1Msec(600);
	motor[backLeft] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[frontRight] = 0;
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	motor[backRight] = 60;
	motor[backLeft] = 60;
	motor[frontLeft] = 60;
	motor[frontRight] = 60;
	wait1Msec(1500);
	motor[backRight] = 0;
	motor[backLeft] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
			//	motor[frontRight] = -65;
			//	motor[backRight] = -65;
			//	motor[frontLeft] = -65;
			//	motor[backLeft] = -65;
			//	wait1Msec(2500);
			//	motor[frontRight] = 0;
			//	motor[backRight] = 0;
			//	motor[frontLeft] = 0;
			//	motor[backLeft] = 0;

			//	//score
			//	//while(close == false)
			//	//{
			//	//	getCloser();
			//	//}
			//	motor[eleBotLeft] = 127;
			//	motor[eleBotRight] = 127;
			//	wait1Msec(2806);
			//	motor[eleBotRight] = 0;
			//	motor[eleBotLeft] = 0;
			//	wait1Msec(500);
			//	motor[eleBotLeft] = -127;
			//	motor[eleBotRight] = -127;
			//	wait1Msec(1000);
			//	motor[eleBotRight] = 0;
			//	motor[eleBotLeft] = 0;
			//done = true;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		//Arcade drive
		motor[backLeft] = vexRT[Ch3] + vexRT[Ch4];
		motor[frontLeft] = vexRT[Ch3] + vexRT[Ch4];
		motor[backRight] = vexRT[Ch3] - vexRT[Ch4];
		motor[frontRight] = vexRT[Ch3] - vexRT[Ch4];

		//Pickup arm
		if(SensorValue[armPot] < 3555)
		{
			motor[armLeft] = vexRT[Ch2];
			motor[armRight] = vexRT[Ch2];
		}
		else
		{
			motor[armLeft] = -15;
			motor[armRight] = -15;
		}

		//Elevator
		if(vexRT[Btn5U] == true)
		{
			motor[eleBotLeft] = 127;
			motor[eleBotRight] = 127;
		}
		else
		{
			if(vexRT[Btn5D] == true)
			{
				motor[eleBotLeft] = -100;
				motor[eleBotRight] = -100;
			}
			else
			{
				motor[eleBotLeft] = 0;
				motor[eleBotRight] = 0;
			}
		}
		//Getting 'closer'
		if(vexRT[Btn8R] == true)
		{
			getCloser();
		}

		//Move a little bit
		if(vexRT[Btn7U]== true)
		{
			motor[backLeft] = 35;
			motor[frontLeft] = 35;
			motor[backRight] = 35;
			motor[frontRight] = 35;
		}
		else
		{
			if(vexRT[Btn7D] == true)
			{
				motor[backLeft] = -35;
				motor[frontLeft] = -35;
				motor[backRight] = -35;
				motor[frontRight] = -35;
			}
			else
			{
				if(vexRT[Btn7L] == true)
				{
					motor[backLeft] = -35;
					motor[frontLeft] = -35;
					motor[backRight] = 35;
					motor[frontRight] = 35;
				}
				else
				{
					if(vexRT[Btn7R] == true)
					{
						motor[backLeft] = 35;
						motor[frontLeft] = 35;
						motor[backRight] = -35;
						motor[frontRight] = -35;
					}
				}
			}
		}
	}
}
