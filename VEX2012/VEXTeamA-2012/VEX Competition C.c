#pragma config(Sensor, in1,    potArm,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  led1,           sensorDigitalOut)
#pragma config(Motor,  port2,           frontLeftMotor, tmotorVex393, openLoop,reversed)
#pragma config(Motor,  port3,           backLeftMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           frontRightMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port5,           backRightMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port6,           armMotorRight, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           armMotorLeft,  tmotorVex393, openLoop)
#pragma config(Motor,  port8,           clawMotor,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"

//deadband, and joystick values
int deadband = 20, joy_x = 0, joy_y = 0;
//set positions of the arm
int usefulArmPositions[4] = {3800, 3600, 3000, 3990};
//point to start at beginning of match (all the way back)
const int STARTING_POINT = 4000;
//command value
int arm_command = STARTING_POINT;

//enumerate values of usefulArmPositions[] array
enum{
	//barely off ground
	HOVERING = 0,
	//level to ground
	LEVEL = 1,
	//AKA scoring position
	PERPENDICULAR = 2,
	//on floor
	HOME = 3
};

/*
	PID loop calculations for arm control
*/
void pid(){
	//D constant gain
  const float d = .5;
  //Kp constant gain
  const float k = .1;
  //Kp constant gain (positive error)
  const int extraSpeed = 9;
  //previous error for D calculation
	static int previousError = 0;
	//error (current - setpoint)
  int error = 0;
  //calculated power value
	int power = 0;
	//calculated D power (added to power)
	float derivative = 0;
	//positive error = going up
	bool goingUp = false;

	//time for D
	if (time1(T1) > 10)
	{
		ClearTimer(T1);
		//calculate error and D value
		error = SensorValue[potArm] - arm_command;
		derivative = (error - previousError) * d;

		//calculate power
		power = (k * error) + derivative;

		//are we going up or down?
		if (error > 0) goingUp = true;

		//add to power based on direction of arm (true = 1, false = 0)
		power += (goingUp * extraSpeed);

		//PID limits
		if (power > 127) power = 127;
		else if (power < -127) power = -127;

		//set power to motors
		motor[armMotorLeft] =  power;
		motor[armMotorRight] = power;

		//get new error
		previousError = error;
	}
}

/*
	setPosition method which updates the command field
*/
void setPosition(int command) {
	arm_command = command;
}

/*
	sets the arm to home position when the required buttons are pressed
*/
void homeAxis(){
	setPosition(usefulArmPositions[HOME]);
}

/*
	method that handles which button is pressed for the arm control
*/
void handleArm() {
	if (vexRT[Btn5U] == 1 && vexRT[Btn6U] == 1) homeAxis();
	if (vexRT[Btn7L] == 1) setPosition(usefulArmPositions[HOVERING]);
	if (vexRT[Btn7U] == 1) setPosition(usefulArmPositions[LEVEL]);
	if (vexRT[Btn7R] == 1) setPosition(usefulArmPositions[PERPENDICULAR]);
}

/*
	method to control arcade drive (right joystick)
*/
void handleDrive() {
	joy_x = vexRT[Ch1];
	joy_y = vexRT[Ch2];

	//forward and swing turns
	if((abs(joy_y) > deadband) && (joy_y > 0)){
		motor[frontLeftMotor]  = (joy_y + joy_x) / 2;
		motor[backLeftMotor]  = (joy_y + joy_x) / 2;
		motor[frontRightMotor] = (joy_y - joy_x) / 2;
		motor[backRightMotor] = (joy_y - joy_x) / 2;
	}
	//backwards and swing turns
	else{
		if((abs(joy_y) > deadband) && (joy_y < 0)){
			motor[frontLeftMotor]  = (joy_y - joy_x)/ 2;
			motor[backLeftMotor]  = (joy_y - joy_x)/ 2;
			motor[frontRightMotor] = (joy_y + joy_x)/ 2;
			motor[backRightMotor] = (joy_y + joy_x)/ 2;
		}
		//turning in place
		else{
			if((abs(joy_x) > deadband) && (abs(joy_y) < deadband)){
				motor[frontLeftMotor]  = joy_x / 2;
				motor[backLeftMotor]  = joy_x / 2;
				motor[frontRightMotor] = (-1 * joy_x) / 2;
				motor[backRightMotor] = (-1 * joy_x) / 2;
			}
			else{
				motor[frontLeftMotor]  = 0;
				motor[frontRightMotor] = 0;
				motor[backLeftMotor] = 0;
				motor[backRightMotor] = 0;
			}
		}
	}
}

/*
	controls LED flashing
*/
void light(){
	if (time1[T2] < 150)
		SensorValue[dgtl1] = 0;
	else{
		if (time1[T2] > 150){
			SensorValue[dgtl1] = 1;
			if (time1[T2] > 300)
				ClearTimer(T2);
		}
	}
}

/*
	shuts the drive off (used in autonomous)
*/
void driveOff(){
	motor[frontLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[backRightMotor] = 0;
}

void pre_auton(){
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = false;
}

/*
	autonomous method, refer to comments for each task/section
*/
task autonomous(){
	ClearTimer(T3);

	//set arm position HOVERING
	setPosition(usefulArmPositions[HOVERING]);
	while(time1[T3] < 1700){
		pid();
	}
	ClearTimer(T3);

	//initial drive forward
	while(time1[T3] < 800){
		motor[frontLeftMotor] = 127;
		motor[backLeftMotor] = 127;
		motor[frontRightMotor] = 127;
		motor[backRightMotor] = 127;
		pid();
	}

	driveOff();
	wait1Msec(150);
	ClearTimer(T3);

	//set arm to HOME
	setPosition(usefulArmPositions[HOME]);
	while(time1[T3] < 800){
		pid();
	}

	driveOff();
	wait1Msec(250);
	ClearTimer(T3);

	//forward into sacks
	while(time1[T3] < 700){
		motor[frontLeftMotor] = 127;
		motor[backLeftMotor] = 127;
		motor[frontRightMotor] = 127;
		motor[backRightMotor] = 127;
		pid();
	}

	driveOff();
	wait1Msec(250);
	ClearTimer(T3);

	//set arm position BACK to HOVERING (PICKS UP THE SACKS)
	setPosition(usefulArmPositions[HOVERING]);
	while(time1[T3] < 500){
		pid();
	}

	wait1Msec(150);
	ClearTimer(T3);

	//set arm position to LEVEL
	setPosition(usefulArmPositions[LEVEL]);
	while(time1[T3] < 600){
		pid();
	}

	//turn slightly to correct offset by omnis
	while(time1[T3] < 125){
		motor[frontLeftMotor] = -63;
		motor[backLeftMotor] = -63;
		motor[frontRightMotor] = 63;
		motor[backRightMotor] = 63;
		pid();
	}

	driveOff();
	wait1Msec(150);
	ClearTimer(T3);

	//backs up to the pile of sacks
	while(time1[T3] < 200){
		motor[frontLeftMotor] = -127;
		motor[backLeftMotor] = -127;
		motor[frontRightMotor] = -127;
		motor[backRightMotor] = -127;
		pid();
	}

	driveOff();
	wait1Msec(150);
	ClearTimer(T3);

	//turns around preparing to score
	while(time1[T3] < 700){
		motor[frontLeftMotor] = -63;
		motor[backLeftMotor] = -63;
		motor[frontRightMotor] = 63;
		motor[backRightMotor] = 63;
		pid();
	}

	driveOff();
	wait1Msec(150);
	ClearTimer(T3);

	//drives forcing the sacks out of the way under the trough
	while(time1[T3] < 1100){
		motor[frontLeftMotor] = -127;
		motor[backLeftMotor] = -127;
		motor[frontRightMotor] = -127;
		motor[backRightMotor] = -127;
		pid();
	}

	driveOff();
	wait1Msec(150);
	ClearTimer(T3);

	//set arm position to PERPENDICULAR (SCORING)
	setPosition(usefulArmPositions[PERPENDICULAR]);
	while(time1[T3] < 1100){
		pid();
	}

	wait1Msec(250);
	ClearTimer(T3);

	setPosition(usefulArmPositions[HOVERING]);
	while(time1[T3] < 1000){
		pid();
	}
}

/*
	fast drive, only forwards and back (goes to full speed)
*/
void handleFastDrive(){
	if (abs(vexRT[Ch3]) > deadband){
		motor[frontLeftMotor] = vexRT[Ch3];
		motor[frontRightMotor] = vexRT[Ch3];
		motor[backLeftMotor] = vexRT[Ch3];
		motor[backRightMotor] = vexRT[Ch3];
	}
}

void armControl(){
	if (vexRT[Btn6U] == 1){
		motor[armMotorLeft] = 127;
		motor[armMotorRight] = 127;
	}
	else{
		if(vexRT[Btn5U] == 1){
			motor[armMotorLeft] = -127;
			motor[armMotorRight] = -127;
		}
		else{
			motor[armMotorLeft] = 0;
			motor[armMotorRight] = 0;
		}
	}
}

void claw(){
	if (vexRT[Btn8R] == 1){
		motor[clawMotor] = 127;
	}
	else{
		if(vexRT[Btn8L] == 1){
			motor[clawMotor] = -127;
		}
		else{
			motor[clawMotor] = 0;
		}
	}
}

/*
	main method, infinitely runs other methods such as PID and handles timers at execution
*/
task usercontrol(){
	ClearTimer(T1);
  ClearTimer(T2);
  ClearTimer(T3);
	while (1==1){
		light();
		handleDrive();
		handleFastDrive();
		armControl();
		claw();
		//handleArm();
		//pid();
	}
}
