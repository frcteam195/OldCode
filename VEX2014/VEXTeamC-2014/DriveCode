#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    rightEncode,    sensorNone)
#pragma config(Sensor, in4,    leftEncode,     sensorNone)
#pragma config(Sensor, dgtl1,  clawEyes,       sensorSONAR_inch)
#pragma config(Motor,  port2,           driveLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftClaw,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftRight,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Code Created in part by Matteo G. and Andrew G.

//liftLock is used to determine if we can use the PID control further down. 
//if either lift button is being used, liftLock will = 1, and stop the pid from working. //
//this is to prevent the lift from rising when the driver doesn't want it to.
int liftLock;


void manualLift()
{
	if (vexRT[Btn6D] == 1)
	{
		motor(liftRight) = 127;
		motor(liftLeft) = 127;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor(liftRight) = -63;
		motor(liftLeft) = -63;
	}
	//the two while statements below are broken. I'm looking into the problem.
	while (vexRT[Btn6D] == 1) || (vexRT[Btn5D] == 1);
	{
		liftLock = 1;
	}
	while (vexRT[Btn6D] == 0) && (vexRT[Btn5D] == 0);
	{
		liftLock = 0;
	}
}

int liftCommand = 200;
//start with 0, then 1, then 2. There ARE three, but "the 0 counts," (Jason Tosta, 2014)
static int liftPosition[3] = {200, 700, 2000};

enum
{
	HOME = 0, CARRY = 1, SCORE = 2
};

void setCommand(int Command)
{
	liftCommand = Command;
}

void Buttons()	//PID control buttons. These allow for quick and easy shifts between lift heights
{
	if (liftLock == 0)
	{
		if(vexRT[btn7D] == 1)
		{
			setCommand(liftPosition[HOME]);
		}
		if(vexRT[btn7L] == 1)
		{
			setCommand(liftPosition[CARRY]);
		}
		if(vexRT[btn7U] == 1)
		{
			setCommand(liftPosition[SCORE]);
		}
	}
}
void slowDrive() //to be used at a later time. Working on button latch for this.
{
	motor(driveLeft) = (vexRT(Ch3) + vexRT(Ch1))/2;
	motor(driveRight) = (vexRT(Ch3) - vexRT(Ch1))/2;
}

void mtndewDrive()
{
	motor(driveLeft) = vexRT(Ch3) + vexRT(Ch1);
	motor(driveRight) = vexRT(Ch3) - vexRT(Ch1);
}

void claw()
{
	if (vexRT[Btn6U] == 1)
	{
		motor(liftClaw) = 127;
	}
	else if(vexRT[Btn5U] ==1)
	{
		motor(liftClaw) = -127;
	}
	else
	{
		motor(liftClaw) = 0;
	}
}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

}

task autonomous()
{
	//there will be stuff here i swear.
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
	liftLock = 0;
	while (true) 
	{	
		/* everything in our usercontrol is done with functions. They are referenced above and 
		can be recognized by the two parenthesis at the end of the statement*/
		mtndewDrive();
		Buttons();
		claw();
		manualLift();
	}
}
