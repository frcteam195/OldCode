#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  clawEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           middle,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftMotorF,    tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightMotorF,   tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           leftMotorB,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port5,           rightMotorB,   tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           clawUpDown,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           armRight,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	SensorValue[armEncoder] = 0;
	SensorValue[clawEncoder] = 0;
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////




void stopMotors()
{
	motor[leftMotorF] = 0;
	motor[leftMotorB] = 0;
	motor[rightMotorF] = 0;
	motor[rightMotorB] = 0;
	motor[middle] = 0;
	motor[armLeft] = 0;
	motor[armRight] = 0;
	motor[clawUpDown] = 0;
}

task autonomous()
{
	SensorValue[armEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	motor[clawUpDown] = -127;
	wait1Msec(1400);
	stopMotors();
	wait1Msec(250);
	while(SensorValue[armEncoder] <= 850)
	{
		motor[armLeft] = 127;
		motor[armRight] = 127;
	}
	stopMotors();
	wait1Msec(100);
	while(SensorValue[leftEncoder] <= 15 && SensorValue[rightEncoder] >= -40)
	{
		motor[leftMotorF] = 63;
		motor[leftMotorB] = 63;
		motor[rightMotorF] = 63;
		motor[rightMotorB] = 63;
	}
	stopMotors();
	wait1Msec(100);
	motor[clawMotor] = -127;
	wait1Msec(200);
	stopMotors();
	while(SensorValue[armEncoder] <= 1510)
	{
		motor[armLeft] = 127;
		motor[armRight] = 127;
	}
	stopMotors();
	wait1Msec(100);
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while(SensorValue[leftEncoder] >= -500 && SensorValue[rightEncoder] >= -480)
	{
		motor[leftMotorF] = -63;
		motor[leftMotorB] = -63;
		motor[rightMotorF] = 63;
		motor[rightMotorB] = 63;
	}
	stopMotors();
	wait1Msec(100);
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while(SensorValue[leftEncoder] <= 60 && SensorValue[rightEncoder] >= -60)
	{
		motor[leftMotorF] = 63;
		motor[leftMotorB] = 63;
		motor[rightMotorF] = 63;
		motor[rightMotorB] = 63;
	}
	stopMotors();
	wait1Msec(100);
	while(SensorValue[armEncoder] >= 575)
	{
		motor[armLeft] = -127;
		motor[armRight] = -127;
	}
	stopMotors();
	wait1Msec(100);
	motor[clawMotor] = 127;
	wait1Msec(200);
	//motor[leftMotorF] = -127;
	//motor[leftMotorB] = -127;
	//motor[rightMotorF] = -127;
	//motor[rightMotorB] = -127;
	//wait1Msec(75);
	//stopMotors();
	//motor[middle] = -127;
	//wait1Msec(1500);
	//stopMotors();
	motor[armLeft] = 127;
	motor[armRight] = 127;
	wait1Msec(1000);
	stopMotors();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		int jiggle = 1;
		int wiggle = 1;

		while(jiggle == wiggle)
		{
			float reduceSpeed = .8;

			motor[leftMotorF]  = vexRT[Ch3] * reduceSpeed;
			motor[leftMotorB]  = vexRT[Ch3] * reduceSpeed;
			motor[rightMotorF] = vexRT[Ch2] * reduceSpeed;
			motor[rightMotorB] = vexRT[Ch2] * reduceSpeed;

			if (vexRT[Btn7R] == 1 && vexRT[Btn7L] == 0)
			{
				motor[middle] = 127;
			}
			else if (vexRT[Btn7L] == 1 && vexRT[Btn7R] == 0)
			{
				motor[middle] = -127;
			}
			else
			{
				motor[middle] = 0;
			}

			if (vexRT[Btn5D] == 1 && vexRT[Btn5U] == 0)
			{
				motor[clawMotor] = 127;
			}
			else if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 0)
			{
				motor[clawMotor] = -127;
			}
			else
			{
				motor[clawMotor] = 0;
			}

			while(vexRT[Btn7D] == 1)
			{
				motor[leftMotorF]  = (vexRT[Ch2]/4);
				motor[leftMotorB]  = (vexRT[Ch2]/4);
				motor[rightMotorF] = (vexRT[Ch2]/4);
				motor[rightMotorB] = (vexRT[Ch2]/4);
				motor[middle] = (vexRT[Ch1])/4;
			}
			if(vexRT[Btn6U] == 1)
			{
				if(SensorValue[armEncoder] <= 1640)
				{
					motor[armLeft] = 127;
					motor[armRight] = 127;
				}
				else
				{
					motor[armLeft] = 0;
					motor[armRight] = 0;
				}
			}
			else if(vexRT[Btn6D] == 1)
			{
				if(SensorValue[armEncoder] >= 125)
				{
					motor[armLeft] = -127;
					motor[armRight] = -127;
				}
				else
				{
					motor[armLeft] = 0;
					motor[armRight] = 0;
				}
			}
			else
			{
				motor[armLeft] = 0;
				motor[armRight] = 0;
			}
			if(vexRT[Btn8R] == 1 && vexRT[Btn8D] == 0)
			{
				motor[clawUpDown] = 127;
			}
			else if(vexRT[Btn8D] == 1 && vexRT[Btn8R] == 0)
			{
				motor[clawUpDown] = -127;
			}
			else
			{
				motor[clawUpDown] = 0;
			}
		}
	}
}
