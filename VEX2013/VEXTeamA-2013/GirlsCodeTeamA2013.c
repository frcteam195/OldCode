#pragma config(Sensor, in2,    Rightpot,       sensorPotentiometer)
#pragma config(Sensor, in3,    Leftpot,        sensorPotentiometer)
#pragma config(Sensor, in4,    Bridgepot,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LED1,           sensorLEDtoVCC)
#pragma config(Motor,  port2,  frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,  backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,  frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,  backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port6,  armRight,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,  armLeft,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,  Drawbridge,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// define constants
const int grabspeed = 40;
const int staycenteredspeed = 25;

void driveMotorsOn(int speed)
{
	motor[frontRight] = speed;
	motor[frontLeft] = speed;
	motor[backRight] = speed;
	motor[backLeft] = speed;
}

task main()
{
  while(1)
	{
		SensorValue[LED1] = true;
		motor[frontRight] = vexRT(Ch2) - vexRT(Ch1);
		motor[backRight] = vexRT(Ch2) - vexRT(Ch1);
		motor[frontLeft] = vexRT(Ch2) + vexRT(Ch1);
		motor[backLeft] = vexRT(Ch2) + vexRT(Ch1);
		//=========================================================RIGHT ARM================================================
		if(SensorValue[Rightpot] > 1273 && SensorValue[Rightpot] < 2339)
		{
			if(vexRT[Btn6U] == 1)
			{
				motor[armRight] = grabspeed;// Positive numbers should drive arm left
			}
			else if(vexRT[Btn6D] == 1)
			{
				motor[armRight] = -grabspeed;//Negative numbers should drive arm right
			}
			else
			{
				motor[armRight] = 0;
			}
		}
		else if(SensorValue[Rightpot] < 1273)
		{
			motor[armRight] = -staycenteredspeed;
		}
		else if(SensorValue[Rightpot] > 2339)
		{
			motor[armRight] = staycenteredspeed;
		}


				//=========================================================LEFT ARM===================================================
		if(SensorValue[Leftpot] < 2628 && SensorValue[Leftpot] > 1673)
		{
			if(vexRT[Btn6U] == 1)
			{
				motor[armLeft] = grabspeed;// Positive numbers should drive arm right
			}
			else if(vexRT[Btn6D] == 1)
			{
				motor[armLeft] = -grabspeed;// Negative numbers should drive arm left
			}
			else
			{
				motor[armLeft] = 0;
			}
		}
		else if(SensorValue[Leftpot] <2628)
		{
			motor[armLeft] = staycenteredspeed;
		}
		else if(SensorValue[Leftpot] > 1673)
		{
			motor[armLeft] = -staycenteredspeed;
		}
		//=======================================AUTONOMOUS===============================================================
		if(vexRT[Btn7U] == 1)
		{
			driveMotorsOn(62);
			wait1Msec(1800);     //Go forward for 1.5 seconds then stop
			driveMotorsOn(0);

			//motor[Drawbridge] = (360 - SensorValue[Bridgepot]) * .1

			while (SensorValue[Leftpot] > 1600 && SensorValue[Rightpot] < 2200)
			{
					motor[armLeft] = -30;
					motor[armRight] = -30;
			}

			motor[armLeft] = 0;
			motor[armRight] = 0;

			driveMotorsOn(-60);
			wait1Msec(1500);    //Go backwards for 1.5 seconds then turn off

    	driveMotorsOn(0);
    	wait1Msec(3000); // Time to reposition

    	driveMotorsOn(-100);
    	wait1Msec(2250); //Go back and hit big ball off

    	driveMotorsOn(0);
    	wait1Msec(1000);

    	driveMotorsOn(65);
    	wait1Msec(2000); //Back to square

    	driveMotorsOn(0);
    	wait1Msec(2000);
		}
		//=======================================DrawBridge===============================================================
		if(SensorValue[Bridgepot] < 1310 && SensorValue[Bridgepot] > 1)
		{
			if(vexRT[Btn5D] == 1)
			{
				motor[Drawbridge] = 127;
			}
			else if(vexRT[Btn5U] == 1)
			{
				motor[Drawbridge] = -127;
			}
			else if(vexRT[Btn7L] == 1)
			{
			motor[Drawbridge] = (360 - SensorValue[Bridgepot]) * .1; //motor[Drawbridge] = (SensorValue[Bridgepot] - desired pot value) * .1;
			}
			else
			{
				motor[Drawbridge] = 0;
			}
		}
		else
		{
			motor[Drawbridge] = (360 - SensorValue[Bridgepot]) * .1; //motor[Drawbridge] = (SensorValue[Bridgepot] - desired pot value) * .
		}
	}
}
